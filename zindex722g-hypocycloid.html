<!DOCTYPE html>
<meta charset='utf-8'>
<title>animas</title>
<head >

  <style>
    body { margin: 0; position: fixed; top: 0; right: 0; bottom: 0; left: 0; }
    div#fps,svg { position: fixed; top: 0; left: 0; color: white; }
  </style>

</head>
<body style='cursor:crosshair'></body>
<div id='viewframe' class='viewframe'></div>
<script src='script-enls.js'></script>
<script src='script-ents.js'></script>

<script>
// md: md:{filename}
// md:   https://en.wikipedia.org/wiki/Hypocycloid

let muonAlima = function muonAlima (__mapper) {
  __mapper({'xs': xs.xs(__mapper)}) // PROXIES
  __mapper('xs').m('init')({canvas: 0, svg: 1, versor: 0, wen: 1, webgl: 0, bck: 0, gui: 0, key: 1, fps: 0, stats: 0}) // INIT

  let f = __mapper({props: muonProps.muonProps()}).props(),
    mnat = __mapper('xs').m('nat'),
    cversor = __mapper('xs').c('versor'),
    cwen = __mapper('xs').c('wen'),
    mstace = __mapper('xs').m('stace'),
    mfourier = __mapper('xs').m('fourier'),
    manimas = __mapper('xs').m('animas'),
    mric = __mapper('xs').m('ric'),
    mstore = __mapper('xs').m('store'),
    mbezierjs = __mapper('xs').m('bezierjs'),
    msvg = __mapper('xs').m('svg'),
    mgeoj = __mapper('xs').m('geoj'),
    mprofier = __mapper('xs').m('profier'),
    mproj3ct = __mapper('xs').m('proj3ct')

  const pi = Math.PI, pi2 = 2 * pi,
    turn = 2 * Math.PI0,
    tau = 2 * Math.PI

  let tim = {'td': 2 ** 2 * 9000, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}

  let _NAME = 'anis'
  _ROW = 2,
  _COL = 2,
  _LEVEL = 2,
  _CF = d => 222 * 1, // cfonlevel
  _SIDES = 5,
  _RAD = 90,
  PHASED = 0 // 0 internal, 180 extenal

  const cyclet = _LEVEL * _LEVEL * 1000

  const x0 = -150,
    dx = 150,
    y0 = -100,
    dy = 100

  let x = x0 + (_COL - 1) * dx,
    y = y0 + (_ROW - 1) * dy

  const signexp = d => Math.pow(-1, d)


  //md: traceline h.pacer pacer.aad:1
  let traceLine = {

    halo: 'pacer',
    payload: {
      ric: {gid: 'traces', cid: 'traces', fid: 'traces'},
      boform: {'csx': 0, 'cf': 444, 'cs': 666, 'cw': 0.99, 'co': 0.1, 'cp': 0.99},

      pacer: { // aad for trace
        stace: {x: { pos: 0 }, y: { pos: 0 }, z: 0}, //
        initN: 0, eventN: 0, autoN: 1, autoP: 0, outtimed: 0, maxN: 60, span: 0, aad: 1,
        autoSitus: function (a) {
          let r = mstace.getLocus(this.stace, a) // situs
          return r
        },
        fidder: a => a.payload.ric.fid,
        geojsor: function (a, i) {
          let ric = a.payload.ric // ric
          let uid = mric.getuid(ric)
          let gj = {
            halo: 'ent',
            geofold: {
              type: 'Feature',
              geometry: { type: 'LineString', coordinates: null },
              properties: { doc: 'pacer' }
            },
            payload: {
              uid: uid, id: uid, ric: ric,
              proform: this.proform
            }
          }
          let newItem = mstore.findAnigramFromUid(uid) || gj
          if (newItem.geofold.properties.formEreformed) {
            newItem.geofold.geometry = newItem.geofold.properties.formEreformed.geometry
          }
          return newItem
        }
      }
    }
  }
  
  //md: rayLine h.ent
  let rayLine = {

    halo: 'ent',
    geofold: {type: 'Feature', geometry: {type: 'LineString', coordinates: []}, properties: {}},
    payload: {
      tim: tim,
      ric: {gid: 'ray', cid: 'ray'},
      boform: {'csx': 0, 'cf': 555, 'cs': 999, 'cw': 0.6, 'co': 0.999, 'cp': 0.999}
    }

  }

  //md: anifractal h.fractal
  let anifractal = {

    halo: 'fractal',

    geofold: a => ({
      type: 'Feature',
      geometry: {type: 'Point', coordinates: [0, 0]},
      properties: {
        pointRadius: a.payload.fractal.rad,
        geonode: {
          type: 'Feature',
          geometry: {type: 'Point', coordinates: [0, 0]},
          properties: {orgen: [0, 0], velin: [0, 0], velang: [0, 0], prevous: [0, 0], geodelta: [0, 0]}
        }
      }
    }),

    payload: {

      tim: tim,
      ric: {'gid': 'fractal', 'cid': 'fractal'}, // fid undefined
      boform: {'csx': 0, 'cf': 555, 'cs': 333, 'cw': 0.9, 'co': 0.2, 'cp': 0.7},

      ereform: {projection: 'uniwen', scale: 1.0, translate: {x: 0, y: 0 }, rotate: [ 0, 0 ]},

      proform: { projection: 'uniwen', scale: 1, translate: [ -0, 0 ], rotate: [ 0, 0 ] },

      fractal: {

        level: 3,
        rad0: 60,
        sides: 3,
        turns: 2,
        phase: 0 * tau,

        rad: function (level, rad0 = 60, sides) {
          let grouplinear = f.grouplinear(2)(level)
          let groupgeometric = f.groupgeometric(2)(level + 0.001)

          let amp = rad0
          let k = 5.5 // sides

          if (level === 0) {
            amp = rad0
          } else if (level === 1) {
            amp = rad0 / (k - 1) // -rad0 / (k - 1)
          } else if (level === 2) {
            amp = rad0 / (k - 1)
          } else {
            amp = rad0 / Math.pow(2, level)
          }

          return amp
        },

        ang: function (level = 2, sides = 4, phase0 = 0) {
          let grouplinear = f.grouplinear(2)(level)
          let k = 5.5 // sides

          let angn0 = 0,
            angn1 = 0

          if (level === 0) {
            angn0 = phase0; angn1 = phase0 + 1 * tau
          } else if (level === 1) {
            angn0 = phase0; angn1 = phase0 - 0 * tau
          } else if (level === 2) {
            angn0 = phase0; angn1 = phase0 - (k - 1) * tau
          } else {
            angn0 = phase0; angn1 = phase0 + (-1) ** (level) * (sides - 1) ** (level) * tau
          }

          let phase = [[[ angn0, angn1 ]]]
          return phase
        },

        zcoef: function (idx, arr) {
          let ret = Complex({re: 0, im: 0})

          let ang = arr[idx].ang
          let rq = arr[idx].rad

          let x = rq * Math.cos(ang)
          let y = rq * Math.sin(ang)

          ret = Complex({re: x, im: y})

          return ret
        },

        traceLine,
        rayLine

      }

    }
  }


  let animas = [
    anifractal // h.fractal
  ]

  return () => __mapper('xs').m('store').apply({'type': 'UPDANIMA', 'caller': 'alima', 'animas': animas})
}

let __mapper = muonMapper.muonMapper()
__mapper({'muonAlima': muonAlima(__mapper)}).muonAlima(__mapper)
</script>
<body style="cursor:crosshair"></body>
