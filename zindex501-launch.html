<!DOCTYPE html>
<meta charset="utf-8">
<title>animas</title>
<head >

  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    div#fps,svg { position: fixed; top:0; left:0; color: white; }
  </style>

</head>
<body style="cursor:crosshair"></body>
<div id="viewframe" class="viewframe"></div>
<script src="elem-enls.js"></script>
<script src="elem-ents.js"></script>

<script>

//md: # md:{filename}
//md:
//md:
//md: ## animas
//md: * [geoearth](#geoearth) -
//md:     worldTopo110m topojson land feature
//md:     init.versor and prerotate cversor
//md:
//md: * [fibofold](#fibofold) - tbd
//md:
//md: ##### avatars
//md:    gratifold - tbd
//md:
//md: # license
//md: MIT

let muonAlima = function muonAlima (__mapper) {
  __mapper({'xs': xs.xs(__mapper)}) // PROXIES
  __mapper('xs').m('init')({svg: 1, versor: 1, wen: 1, webgl: 0, bck: 0, key: 1}) // INIT

  let mnat = __mapper('xs').m('nat'),
    mliner = __mapper('xs').m('liner'),
    manitem = __mapper('xs').m('anitem'),
    mgeom = __mapper('xs').m('geom'),
    mgeoj = __mapper('xs').m('geoj'),
    mfibonat = __mapper('xs').m('fibonat'),
    msnap = __mapper('xs').m('snap'),
    mprofier = __mapper('xs').m('profier'),
    mversor = __mapper('xs').m('versor'),
    cwen = __mapper('xs').c('wen'),
    cversor = __mapper('xs').c('versor')

  const cos = Math.cos, sin = Math.sin

  // .................. enty
  let tim = {'td': 72200, 't0': 0, 't1': 1000, 't2': 1, 't3': 1}

  let natform = {

    'x': {
      'm1': 6,'m2': 6,'n1': 60,'n2': 100,'n3': 30,'a': 1,'b': 1,
      'ra2': 26,'v0': 0,'v1': 1,'w4': 0,'seg5': 360,'pa6': 0,'pb7': -1,
      'dom3': [0, 360],
      'fn0': (r,s, u=0,v=0, a,b, c=1,d=1) =>
              (a * cos(r) * c * cos(u)) * (a * cos(r) * c * cos(u))
    },
    'y': {
      'm1': 2,'m2': 2,'n1': 1,'n2': 1,'n3': 1,'a': 1,'b': 1, // biform
      'ra2': 18,'v0': 0,'v1': 1,'w4': 0,'seg5': 360,'pa6': 0,'pb7': -1,

      'dom3': [0, 360],
      'fn0': (r,s, u=0,v=0, a,b, c=1,d=1) => 1

    },
    'z': {
      'm1': 2,'m2': 2,'n1': 1,'n2': 1,'n3': 1,'a': 1,'b': 1, // biform
      'ra2': 26,'v0': 0,'v1': 1,'w4': 0,'seg5': 360,'pa6': 0,'pb7': -1,

      'dom3': [0, 360],
      'fn0': (r,s, u=0,v=0, a,b, c=1,d=1) => d * sin(v)

    }
  }

  let pathform = {

    'x': {
      'm1': [[[4, 4]]],'m2': [[[4, 4]]],'n1': [[[2, 2]]],'n2': [[[2, 2]]],'n3': [[[2, 2]]],'a': [[[1, 1]]],'b': [[[1, 1]]], // moon
      'ra2': 160,'v0': 0,'v1': 1,'seg5': 360,'w4': 0,'pa6': 0,'pb7': -1,

    },
    'y': {
      'm1': [[[4, 4]]],'m2': [[[4, 4]]],'n1': [[[2, 2]]],'n2': [[[2, 2]]],'n3': [[[2, 2]]],'a': [[[1, 1]]],'b': [[[1, 1]]], // moon
      'ra2': 160,'v0': 0,'v1': 1,'seg5': 360,'w4': 0,'pa6': 0,'pb7': -1,

    },
    'z': {
      'm1': [[[4, 4]]],'m2': [[[4, 4]]],'n1': [[[2, 2]]],'n2': [[[2, 2]]],'n3': [[[2, 2]]],'a': [[[1, 1]]],'b': [[[0.95, 0.98]]], // moon
      'ra2': 160,'v0': 0,'v1': 1,'seg5': [[[360, 360]]],'w4': [[[0, 0 - 0 * 360]]],'pa6': 0,'pb7': -1,
    }

  }

  let proform = {
    'projection': 'uniwen',
    'prerotate': [[[ cwen.rotation ]]],
    'translate': [0, 0, 0],
    'scale': 1,
    'rotate': [ [[[0, 90]]], [[[0, 90]]], 0 ],
    'lens': [0, 1, Infinity],
  }

  let geonode = {
    type: 'Feature',
    geometry: { type: 'Point', coordinates: [0, 0, 0] },
    properties: {}
  }

  let graticule = {

    'frame': [ [ [-180, 180, 90, 9], [-90, 90, 45, 5] ],
              [ [-180, 180, 90, 9], [-90, 90, 45, 5] ] ]

  }

  let fibonat = {
    randomize: 0,
    samples: 12,
    dotsInSegment: 12
  }

  // .................. geoearth
  let geoearth = {

    halo: 'ent',

    geofold: () => {
      let gj = Object.assign({},
        topojson.feature(
          __mapper('xs').d('worldTopo110m').data(),
          __mapper('xs').d('worldTopo110m').data().objects.land
        )
      )
      return mgeoj.trim(gj)
    },

    payload: {
      tim: tim,
      ric: {'gid': 'geoearth', 'cid': 'geoearth', 'fid': 'geoearth'},
      boform: { 'csx': 0, 'cf': [[[333, 333]]], 'cs': 333, 'cw': 0.2, 'co': 0.4, 'cp': 0.9},
      proform: {

        'projection': 'orthographic',
        'prerotate': [[[ cversor.rotation ]]],
        'scale': 100,
        'translate': {
          'x': 0,
          'y': 0,
          'z': 0
        },
        'rotate': [ 0, 0, 0 ],
        // 'control': 'versor'

      }
    }

  }
  // .................. fibofold
  let fibofold = {

    halo: 'ent',

    geofold: p => {
      let coords = mfibonat.stream(p.payload.fibonat)	// spherical
      return {
        type: 'Feature',
        geometry: {type: 'LineString', coordinates: coords},
        properties: {}
      }
    },

    payload: {
      tim: tim,
      ric: {'gid': 'nat', 'cid': 'nat', 'fid': 'fibofold'},
      boform: { 'csx': 0, 'cf': [[[777, 777, 777]]], 'co': [[[0.2, 0.2]]], 'cs': [[[777, 888]]], 'cw': [[[0.2, 0.2]]], 'cp': [[[0.9, 0.9]]]},

      fibonat: fibonat,
      conform: { projection: 'natform', form: pathform },
      proform: proform

    }

  }

  // .................. gratifold
  let gratifold = {

    halo: 'ent',

    geofold: p => __mapper('xs').m('graticule').vhMultiLine(p.payload.graticule),

    payload: {
      tim: tim,
      ric: {'gid': 'gratifold', 'cid': 'gratifold', 'fid': 'gratifold'},
      boform: { 'csx': 0, 'cf': [[[555, 555]]], 'cs': 333, 'cw': 0.9, 'co': [[[0.5, 0.5]]], 'cp': [[[0.9, 0.9, 0.9]]]},

      fibonat: fibonat,
      conform: { projection: 'natform', form: natform },
      proform: {
        projection: 'uniwen',
        translate: {
          'x': { pos: [[[ 0, 1 * 360]]] , geo: 1},
          'y': { pos: [[[ 0, 1 * 360]]] , geo: 1},
          'z': { pos: [[[ 0, 1 * 360]]] , geo: 1}
        },
        scale: 0.5

      },
      graticule: graticule

    }

  }


  // .................. animaApi
  fibofold.avatars = {
    gratifold
  }

  let animas = [

    fibofold, // h.ent
    // geoearth, // h.ent g.orthographic
  ]

  let animaApi = function animaApi () {
    __mapper('xs').m('store').apply({'type': 'UPDANIMA', 'caller': 'alima', 'animas': animas})
  }

  return animaApi
}

let __mapper = xMapper.xMapper()
__mapper({'muonAlima': muonAlima(__mapper)}).muonAlima(__mapper)
</script>
<body style="cursor:crosshair"></body>
